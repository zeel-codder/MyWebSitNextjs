{"ast":null,"code":"\"use strict\";\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _escapeStringRegexp = _interopRequireDefault(require(\"next/dist/compiled/escape-string-regexp\"));\n\nvar _nodeHtmlParser = require(\"node-html-parser\");\n\nvar _constants = require(\"./constants\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // const MIDDLEWARE_TIME_BUDGET = parseInt(process.env.__POST_PROCESS_MIDDLEWARE_TIME_BUDGET || '', 10) || 10\n\n\nvar MAXIMUM_IMAGE_PRELOADS = 2;\nvar IMAGE_PRELOAD_SIZE_THRESHOLD = 2500;\nvar middlewareRegistry = [];\n\nfunction registerPostProcessor(name, middleware, condition) {\n  middlewareRegistry.push({\n    name,\n    middleware,\n    condition: condition || null\n  });\n}\n\nfunction processHTML(_x, _x2, _x3) {\n  return _processHTML.apply(this, arguments);\n}\n\nfunction _processHTML() {\n  _processHTML = _asyncToGenerator(function* (html, data, options) {\n    // Don't parse unless there's at least one processor middleware\n    if (!middlewareRegistry[0]) {\n      return html;\n    }\n\n    var root = (0, _nodeHtmlParser.parse)(html);\n    var document = html; // Calls the middleware, with some instrumentation and logging\n\n    function callMiddleWare(_x9) {\n      return _callMiddleWare.apply(this, arguments);\n    }\n\n    function _callMiddleWare() {\n      _callMiddleWare = _asyncToGenerator(function* (middleware) {\n        // let timer = Date.now()\n        var inspectData = middleware.inspect(root, data);\n        document = yield middleware.mutate(document, inspectData, data); // timer = Date.now() - timer\n        // if (timer > MIDDLEWARE_TIME_BUDGET) {\n        // TODO: Identify a correct upper limit for the postprocess step\n        // and add a warning to disable the optimization\n        // }\n\n        return;\n      });\n      return _callMiddleWare.apply(this, arguments);\n    }\n\n    for (var i = 0; i < middlewareRegistry.length; i++) {\n      var middleware = middlewareRegistry[i];\n\n      if (!middleware.condition || middleware.condition(options)) {\n        yield callMiddleWare(middlewareRegistry[i].middleware);\n      }\n    }\n\n    return document;\n  });\n  return _processHTML.apply(this, arguments);\n}\n\nclass FontOptimizerMiddleware {\n  constructor() {\n    this.mutate = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (markup, fontDefinitions, options) {\n        var result = markup;\n\n        if (!options.getFontDefinition) {\n          return markup;\n        }\n\n        fontDefinitions.forEach(fontDef => {\n          var [url, nonce] = fontDef;\n          var fallBackLinkTag = \"<link rel=\\\"stylesheet\\\" href=\\\"\".concat(url, \"\\\"/>\");\n\n          if (result.indexOf(\"<style data-href=\\\"\".concat(url, \"\\\">\")) > -1 || result.indexOf(fallBackLinkTag) > -1) {\n            // The font is already optimized and probably the response is cached\n            return;\n          }\n\n          var fontContent = options.getFontDefinition ? options.getFontDefinition(url) : null;\n\n          if (!fontContent) {\n            /**\n            * In case of unreachable font definitions, fallback to default link tag.\n            */\n            result = result.replace('</head>', \"\".concat(fallBackLinkTag, \"</head>\"));\n          } else {\n            var nonceStr = nonce ? \" nonce=\\\"\".concat(nonce, \"\\\"\") : '';\n            result = result.replace('</head>', \"<style data-href=\\\"\".concat(url, \"\\\"\").concat(nonceStr, \">\").concat(fontContent, \"</style></head>\"));\n          }\n        });\n        return result;\n      });\n\n      return function (_x4, _x5, _x6) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n  }\n\n  inspect(originalDom, options) {\n    if (!options.getFontDefinition) {\n      return;\n    }\n\n    var fontDefinitions = []; // collecting all the requested font definitions\n\n    originalDom.querySelectorAll('link').filter(tag => tag.getAttribute('rel') === 'stylesheet' && tag.hasAttribute('data-href') && _constants.OPTIMIZED_FONT_PROVIDERS.some(url => {\n      var dataHref = tag.getAttribute('data-href');\n      return dataHref ? dataHref.startsWith(url) : false;\n    })).forEach(element => {\n      var url = element.getAttribute('data-href');\n      var nonce = element.getAttribute('nonce');\n\n      if (url) {\n        fontDefinitions.push([url, nonce]);\n      }\n    });\n    return fontDefinitions;\n  }\n\n}\n\nclass ImageOptimizerMiddleware {\n  constructor() {\n    this.mutate = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (markup, imgPreloads) {\n        var result = markup;\n        var imagePreloadTags = imgPreloads.filter(imgHref => !preloadTagAlreadyExists(markup, imgHref)).reduce((acc, imgHref) => acc + \"<link rel=\\\"preload\\\" href=\\\"\".concat(imgHref, \"\\\" as=\\\"image\\\"/>\"), '');\n        return result.replace(/<link rel=\"preload\"/, \"\".concat(imagePreloadTags, \"<link rel=\\\"preload\\\"\"));\n      });\n\n      return function (_x7, _x8) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n  }\n\n  inspect(originalDom) {\n    var imgPreloads = [];\n    var imgElements = originalDom.querySelectorAll('img');\n    var eligibleImages = [];\n\n    for (var i = 0; i < imgElements.length; i++) {\n      if (isImgEligible(imgElements[i])) {\n        eligibleImages.push(imgElements[i]);\n      }\n\n      if (eligibleImages.length >= MAXIMUM_IMAGE_PRELOADS) {\n        break;\n      }\n    }\n\n    for (var imgEl of eligibleImages) {\n      var src = imgEl.getAttribute('src');\n\n      if (src) {\n        imgPreloads.push(src);\n      }\n    }\n\n    return imgPreloads;\n  }\n\n}\n\nfunction isImgEligible(imgElement) {\n  var imgSrc = imgElement.getAttribute('src');\n  return !!imgSrc && sourceIsSupportedType(imgSrc) && imageIsNotTooSmall(imgElement) && imageIsNotHidden(imgElement);\n}\n\nfunction preloadTagAlreadyExists(html, href) {\n  var escapedHref = (0, _escapeStringRegexp.default)(href);\n  var regex = new RegExp(\"<link[^>]*href[^>]*\".concat(escapedHref));\n  return html.match(regex);\n}\n\nfunction imageIsNotTooSmall(imgElement) {\n  // Skip images without both height and width--we don't know enough to say if\n  // they are too small\n  if (!(imgElement.hasAttribute('height') && imgElement.hasAttribute('width'))) {\n    return true;\n  }\n\n  try {\n    var heightAttr = imgElement.getAttribute('height');\n    var widthAttr = imgElement.getAttribute('width');\n\n    if (!heightAttr || !widthAttr) {\n      return true;\n    }\n\n    if (parseInt(heightAttr) * parseInt(widthAttr) <= IMAGE_PRELOAD_SIZE_THRESHOLD) {\n      return false;\n    }\n  } catch (err) {\n    return true;\n  }\n\n  return true;\n} // Traverse up the dom from each image to see if it or any of it's\n// ancestors have the hidden attribute.\n\n\nfunction imageIsNotHidden(imgElement) {\n  var activeElement = imgElement;\n\n  while (activeElement.parentNode) {\n    if (activeElement.hasAttribute('hidden')) {\n      return false;\n    }\n\n    activeElement = activeElement.parentNode;\n  }\n\n  return true;\n} // Currently only filters out svg images--could be made more specific in the future.\n\n\nfunction sourceIsSupportedType(imgSrc) {\n  return !imgSrc.includes('.svg');\n} // Initialization\n\n\nregisterPostProcessor('Inline-Fonts', new FontOptimizerMiddleware(), // Using process.env because passing Experimental flag through loader is not possible.\n// @ts-ignore\noptions => options.optimizeFonts || process.env.__NEXT_OPTIMIZE_FONTS);\nregisterPostProcessor('Preload Images', new ImageOptimizerMiddleware(), // @ts-ignore\noptions => options.optimizeImages || process.env.__NEXT_OPTIMIZE_IMAGES);\nvar _default = processHTML;\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}